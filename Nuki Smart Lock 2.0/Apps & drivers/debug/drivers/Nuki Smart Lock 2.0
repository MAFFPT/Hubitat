/*
    Copyright 2020 Marco Felicio (maffpt@gmail.com)

    Licensed under the Creative Commons (CC) Attribution-NonCommercial 4.0 International (CC BY-NC 4.0) - the "License";
    you may not use this file except in compliance with the License.
    
    You may obtain a copy of the License at

        https://creativecommons.org/licenses/by/4.0/

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    
    See the License for the specific language governing permissions and
    limitations under the License.
*/

import groovy.transform.Field

@Field static Map _lockActions = [1: "Unlock", 2: "Lock", 3: "Unlatch", 4: "lockNGo", 5: "lockNGoUnlatch"]
@Field static Map _lockStates = [0: "Uncalibrated", 1: "Locked", 2: "Unlocking", 3: "Unlocked", 4: "Locking", 5: "Unlatched", 6: "Unlocked lockNGo", 7: "Unlatching", 253: "Booting", 254: "Motor Blocked", 255: "Undefined"]
@Field static Map lockActions2 = [0: "NO_ACTION", 1: "UNLOCK", 2: "LOCK", 3: "UNLATCH", 4: "LOCK_N_GO", 5: "LOCK_N_GO_WITH_UNLATCH"]
@Field static Map lockDoorStatus = [0: "UNAVAILABLE", 1: "DEACTIVATED", 2: "DOOR_CLOSED", 3: "DOOR_OPENED", 4: "DOOR_STATE_UNKNOWN", 5: "CALIBRATING"]
@Field static Map lockButtonActions = [0: "NO_ACTION", 1: "INTELLIGENT", 2: "UNLOCK", 3: "LOCK", 4: "UNLATCH", 5: "LOCK_N_GO", 6: "SHOW_STATUS"]

@Field static _nukiLockTypeName = "Nuki Smart Lock 2.0"    // Nuki Smart Lock 2.0's device driver name

@Field static String _deviceTypeSmartLock = "0"

metadata 
{
    definition (name: "Nuki Smart Lock 2.0", namespace: "maffpt", author: "Marco Felicio") 
    {
        capability "Battery"
        
//        capability "DoorControl"
//        command "close"
//        command "open"
        
        capability "Health Check"
        command "ping"

        capability "Lock"
        command "lock"
        command "unlock"
        command "lockNGo"

        capability "Refresh"
        command "refresh"
        
        command "getLog"
        command "status"
    }

    preferences 
    {
        input ("debugLogging",
               "bool",
               defaultValue: false,
               required: false,
               submitOnChange: true,
               title: "Enable debug logging\n<b>CAUTION:</b> a lot of log entries will be recorded!")
    }
    
    tiles 
    {
/*
        multiAttributeTile (name:"lock", type: "generic", width: 6, height: 4)
        {
            tileAttribute ("lock", key: "PRIMARY_CONTROL")
            {
                attributeState "locked", label:'Locked', action:"lock.unlock", icon:"st.locks.lock.locked"
                attributeState "unlocked", label:'Unlocked', action:"lock.lock", icon:"st.locks.lock.unlocked"
                attributeState "locking", label:'Locking', icon:"st.locks.lock.locked"
                attributeState "unlocking", label:'Unlocking', icon:"st.locks.lock.unlocked"
                attributeState "waiting", label: "Waiting", icon:"st.locks.lock.locked"
                attributeState "lockngo",label: "LockNgo - UNLOCKED", icon:"st.locks.lock.locked"

            }
            tileAttribute ("device.battery", key: "SECONDARY_CONTROL") 
            {
                attributeState "battery", label: 'battery ${currentValue}%', unit: "%"
            }
         }
*/
        standardTile ("getLog", "getLog", inactiveLabel: false, decoration: "flat", width: 3, height: 2) 
        {
        	state "default", action:"getLog", icon: "st.locks.lock.locked"
    	}

        standardTile ("lockNGo", "lockNGo", inactiveLabel: false, decoration: "flat", width: 3, height: 2) 
        {
            state "default", label:'lock&Go', action:"lockNGo", icon: "st.locks.lock.locked"
        }
        
        standardTile ("refresh", "device.refresh", inactiveLabel: false, decoration: "flat", width: 3, height: 2) 
        {
        	state "default", action:"refresh", icon:"st.secondary.refresh"
    	}
    }
}


def initialize () 
{
  	logDebug "initialize: IN"
    logDebug "initialize: device.capabilities = ${device.capabilities}"
    logDebug "initialize: OUT"
}


def installed ()
{
    // if the parend device was running with debugLogging, it will automatically passed to this device
    if (device.data.DebugLoggingRequired)
    {
        debugLogging = true
    }

  	logDebug "installed: IN"

    initialize()

    logDebug "installed: installed device ${device.data}"
    logDebug "installed: OUT"
}


def parse (Map jsonMap)
{
    logDebug "parse: IN"
    logDebug "parse: received jsonMap = ${jsonMap}"
    logDebug "parse: device.capabilities = ${device.capabilities}"

    //[deviceType:0, mode:2, stateName:unlocked, nukiId:474312701, state:3, batteryCritical:false]
    
    // Let's first be sure that the NukiIds of this device and the parsed one are the same
    if (jsonMap.nukiId.toString () != device.data.data.DeviceId.toString ())
    {
        trow new Exception ("${device.data.label}: Inconsistent data - events from device with Nuki ID '${jsonMap.nukiId.toString ()}' cannot be handled by device hander for device '${device.data.data.DeviceId.toString ()}'")
    }
    
    logInfo "${device.data.label}: Status changed on this device to ${jsonMap.stateName.toUpperCase ()}. Battery status is ${jsonMap.batteryCritical ? "CRITICAL" : "NORMAL"}."

    sendEvent (name: "lock", value: jsonMap.stateName)
    sendStatusEvent (jsonMap.stateName)
    sendBatteryEvent (batteryCritical)

    logDebug "parse: OUT"
}


def parse (String description)
{
    logDebug "parse: IN"
    
    def parsedDescription = parseLanMessage (description)
    logDebug "parse: parsed description = ${parsedDescription}"
    
    logDebug "parse: OUT"
}


def refresh () 
{
  	logDebug "refresh: beginning"
/*    
	logDebug "refresh: Refreshing ..."
    def params = [uri: "https://api.nuki.io/smartlock/${nukiId}",
                  requestContentType: "application/json",
                  headers: ['Authorization': "Bearer ${api_token}"]]
    try
    {
	    httpGet(params)
		{
            resp ->           
        	    logDebug "refresh: resp data: ${resp.data}"
                logDebug "refresh: Battery is Critical: ${resp.data.state.batteryCritical}"
                sendEvent (name: "battery", value: resp.data.state.batteryCritical ? 0 : 100)
                switch (resp.data.state.state)
                {
                    case 1:
                        sendEvent(name: "lock", value: "locked")
                        break
                    case 2:
                        sendEvent(name: "lock", value: "Unlocking")
                        runIn (5, refresh)
                        break
                    case 3:
                        sendEvent(name: "lock", value: "unlocked")
                        break
                    case 4:
                        sendEvent(name: "lock", value: "locking")
                        runIn(5, refresh)
                        break
                    case 6:
                        sendEvent(name: "lock", value: "lockngo")
                        runIn(5, refresh)
                        break
                    default:
                        sendEvent(name: "lock", value: "waiting")
                        runIn(5, refresh)
                        break
                }
        }
    }
    catch (e)
    {
        logDebug "Error ${e}"
    }     
*/
    logDebug "refresh: finishing"
}


def updated () 
{
    logDebug "updated: beginning"

//    runEvery1Minute(refresh)

    logDebug "updated: finishing"
}


// ======================================
// Device specific methods
// ======================================

//
// Lock
//
def lock (Map cmds) 
{
    logDebug "lock: IN"
    logDebug "lock: cmds = ${cmds}"
    //logDebug "lock: device.capabilities = ${device.capabilities}"

    sendCommandToNuki ("lock",             // actionDescription
                       true,               // waitCompletition
                       "lock",             // eventName
                       "locking",          // eventInProcess
                       "locked",           // eventSuccessValue
                       "locking failed",   // eventFailureValue
                       5)                  // runInTime

    logDebug "lock: OUT"
}


def lockNGo ()
{
    logDebug "lockNGo: beginning"

    sendCommandToNuki ("lockNgo",          // actionDescription
                       true,               // waitCompletition
                       "lock",             // eventName
                       "locking",          // eventInProcess
                       "locked",           // eventSuccessValue
                       "locking failed",   // eventFailureValue
                       30)                  // runInTime

    logDebug "lockNGo: finishing"
}


def unlock (Map cmds) 
{
    logDebug "unlock: IN"
    logDebug "unlock: cmds = ${cmds}"

    sendCommandToNuki ("unlock",           // actionDescription
                       true,               // waitCompletition
                       "unlock",           // eventName
                       "unlocking",        // eventInProcess
                       "unlocked",         // eventSuccessValue
                       "unlocking failed", // eventFailureValue
                       5)                  // runInTime
    logDebug "unlock: OUT"
}


def getLog ()
{
    logDebug "getLog: beginning"
    
    def nukiLog = sendRequestToNuki (request: "log").data
    logDebug "getLog: processing response"    
    nukiLog.each
    {
        logInfo (it.value)
    }
    
    logDebug "getLog: finishing"
}


//=========================================
//    Support stuff
//=========================================

def captureState (data)
{
    logDebug "captureState: beginning"
    data.each 
    {
        logDebug ("captureState: adding ${it.value} to state [${it.key}]")
        state[it.key] = it.value
    }
    logDebug "captureState: finishing"
}


//
// Format and send a command to the Nuki device, handling the result
//
def sendCommandToNuki (String actionDescription, 
                       boolean waitCompletition, 
                       String eventName, 
                       String eventInProcess,
                       String eventSuccessValue, 
                       String eventFailureValue,
                       int runInTime)
{
    logDebug "sendCommandToNuki: IN"
    logDebug "sendCommandToNuki: Processing ${actionDescription.toUpperCase()} command"

    def returnData
        
    def deviceStatus
    def actionDescriptionUCase = actionDescription.toUpperCase ()
    def actionDescriptionLCase = actionDescription.toLowerCase ()
    def endLoop = false
    def sendCommand = false
    def errorMessage = ""
    
    sendStatusEvent (eventInProcess)
    
    //logDebug "sendCommandToNuki: device.data.data = ${device.data.data}"
    for (i in 1..3) 
    {
        deviceStatus = parent.getNukiDeviceStatus (device.data.data)
        logDebug "sendCommandToNuki: deviceStatus = ${deviceStatus}"
        //def teste = "MOTOR BLOCKED"
        
        switch (deviceStatus.lastKnownState.stateName.toUpperCase ())
        //switch (teste)
        {
            case "UNCALIBRATED":
                errorMessage = "Nuki device not calibrated - use Nuki smartphone app to calibrate it"
                sendCommand = false
                endLoop = true
                break
            case "LOCKED":
                switch (actionDescriptionUCase)
                {
                    case "LOCK":
                    case "LOCK 'N' GO":
                    case "LOCK 'N' GO WITH UNLATCH":
                        errorMessage = "Nuki device already locked - ${actionDescriptionUCase} command ignored"
                        sendCommand = false
                        endLoop = true
                        break
                    case "UNLATCH":
                    case "UNLOCK":
                        sendCommand = true
                        endLoop = true
                        break
                    default:
                        break
                }
                break
            case "LOCKING":
            case "UNLATCHING":
            case "UNLOCKING":
                // Let's give some time to the lock to complete the current operation
                break
            case "UNLATCHED":
            case "UNLOCKED":
            case "UNLOCKED (LOCK 'N' GO)":
                switch (actionDescriptionUCase)
                {
                    case "LOCK":
                    case "LOCK 'N' GO":
                    case "LOCK 'N' GO WITH UNLATCH":
                        sendCommand = true
                        endLoop = true
                        break
                    case "UNLATCH":
                    case "UNLOCK":
                        errorMessage = "Nuki device already unlocked - ${actionDescriptionUCase} command ignored"
                        sendCommand = false
                        endLoop = true
                        break
                    default:
                        break
                }
                break
            case "MOTOR BLOCKED":
                errorMessage = "Nuki lock motor blocked - calibrate the lock using the Nuki smartphone app; please check system log for more information on how to proceed"
                logWarn "${device.data.label}: 9. When the calibration is finhised, re-execute the previously failed operation"
                logWarn "${device.data.label}: 8. Follow the instructions provided by the Nuki app"
                logWarn "${device.data.label}: 7. Select the 'Calibrate Smart Lock' option"
                logWarn "${device.data.label}: 6. Select the 'Manage Smart Lock' option"
                logWarn "${device.data.label}: 5. Choose this smart lock (${device.data.label})"
                logWarn "${device.data.label}: 4. Select the 'Smart Lock' option"
                logWarn "${device.data.label}: 3. Select the 'Manage my devices' menu item"
                logWarn "${device.data.label}: 2. Open the Nuki menu (touch the tree bars icon on the top left part of the screen)"
                logWarn "${device.data.label}: 1. Access the Nuki app on your smartphone"
                logWarn "${device.data.label}: To unblock it, follow these instructions:"
                logWarn "${device.data.label}: The motor in this Nuki smart lock is blocked"
                sendCommand = false
                endLoop = true
                break
            case "UNDEFINED":
                errorMessage = "Nuki device has an UNDEFINED status - please try again latter"
                sendCommand = false
                endLoop = true
                break
        }
        if (endLoop)
        {
            break
        }
        logInfo "sendCommandToNuki: pausing for 1.5 seconds"
        pauseExecution (1500)
    }

    if (sendCommand)
    {
        try
        {
            //def bridgeURL = parent.buildBridgeURL (parent.data) + "/lockAction"
            //def commandToSend = buildNukiLockActionCommand (actionDescription, waitCompletition)
            def httpRequest = "${parent.buildBridgeURL (parent.data)}/lockAction?${buildNukiLockActionCommand (actionDescription, waitCompletition)}"
            logDebug "sendCommandToNuki: httpRequest = ${httpRequest})"
    	    httpGet (httpRequest)
            {
                resp -> 
                    returnData = resp?.data
            }
            if (returnData?.success == true)
            {
                logDebug "sendCommandToNuki: event name = lock - value = ${eventSuccessValue}"
                sendEvent (name: "lock", value: eventSuccessValue)
            }
        }
        catch (err)
        {
            logDebug ("sendCommandToNuki: Error on httpPost = ${err}")
        }
    }
    else if (errorMessage != "")
    {
        sendEvent (name: "error", value: "failed ${actionDescription} operation - see device events for more information by clicking on the 'Events' button at the top of this page", descriptionText: "${errorMessage}", displayed: true)
        sendStatusEvent (eventFailureValue, errorMessage)
        logWarn "${_nukiLockTypeName}: ${errorMessage}"
        returnData = false
    }
    else
    {
        sendStatusEvent (eventSuccessValue)
    }
    logDebug "sendCommandToNuki: OUT"
    
    return returnData
}


def buildNukiLockActionCommand (actionDescription, waitCompletition)
{
    logDebug "buildNukiLockActionCommand: IN"
    logDebug "buildNukiLockActionCommand: actionDescription = ${actionDescription}, waitCompletition = ${waitCompletition}"
    
    // Translating the action code description into the corresponding numeric code
    // I should be using an enum ... I miss it!
    def actionCode 
    def httpBody
    logDebug "buildNukiLockActionCommand: # of actions = ${_lockActions.size ()}"
    actionCode = _lockActions.find { it.value.toUpperCase () == actionDescription.toUpperCase() }
    logDebug "buildNukiLockActionCommand: actionCode = ${actionCode}"
    
    // If the translation went well, let's build the command to send to Nuki
    if (actionCode != null)
    {
        logDebug "buildNukiLockActionCommand: device.data.data = ${device.data.data}"
        httpBody = "nukiId=${device.data.data.DeviceId}" +
                   "&deviceType=${_deviceTypeSmartLock}" +
                   "&action=${actionCode.key}" +
                   "&token=${parent.data.Token}" +
                   "&nowait=${waitCompletition ? 0 : 1}"
    }
    else
    {
        log.debug "buildNukiLockActionCommand: OUT with exception"
        throw new Exception ("Invalid action description (${actionDescription})")
    }
    logDebug "buildNukiLockActionCommand: httpBody = ${httpBody}"
    logDebug "buildNukiLockActionCommand: OUT"

    return httpBody
}

def sendRequestToNuki (String request)
{
    logDebug "Processing ${request} request"
    
    def returnData
    
    try
    {
        def requestToSend = buildNukiLockRequest (request)
    	httpPost ( requestToSend )
        {
            resp ->
                returnData = resp.data
        }
    }
    catch (err)
    {
        handleHttpError (err)
    }

    return returnData
}


def buildNukiLockRequest (request)
{
    def requestToSend = "http://${state.ip}/${request}?" +
                        "token=${state.token}"
    
    return requestToSend
}


def handleHttpError (errorCode)
{
    logDebug "handleHttpError: IN"
    logDebug "handleHttpError: errorCode = ${errorCode}"
    switch (errorCode)
    {
        case 401:
            sendEvent (name: "errorCode", value: "Invalid token")
            break
        case 403:
            sendEvent (name: "errorCode", value: "Authentication disabled")
            break
        case 404:
            sendEvent (name: "errorCode", value: "Nuki device unknown")
            break
        case 503:
            sendEvent (name: "errorCode", value: "Nuki device is offline")
            break
        default:
            sendEvent (name: "errorCode", value: "Unexpected error (${errorCode})")
            break
    }
    
    logDebug "handleHttpError: OUT"
}


def sendBatteryEvent (batteryCritical)  
{
    logDebug "sendBatteryEvent: IN"

    sendEvent (name: "battery", value: (batteryCritital ? 20 : 100), unit: "%")          

    logDebug "sendBatteryEvent: OUT"
}


def sendStatusEvent (status, message = "")
{
    logDebug "sendStatusEvent: IN"

    sendEvent (name: "operation status", value: status, descriptionText: message)          

    logDebug "sendStatusEvent: OUT"
}


// Logging stuff
def logDebug (message) { if (debugLogging) log.debug (message) }
def logInfo  (message) { log.info (message) }
def logWarn  (message) { log.warn (message) }
