/*
    Copyright 2020 Marco Felicio (maffpt@gmail.com)

    Licensed under the Creative Commons (CC) Attribution-NonCommercial 4.0 International (CC BY-NC 4.0) - the "License";
    you may not use this file except in compliance with the License.
    
    You may obtain a copy of the License at

        https://creativecommons.org/licenses/by-nc-sa/4.0/

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    
    See the License for the specific language governing permissions and
    limitations under the License.
*/

import groovy.transform.Field

@Field static Map _lockActions = [1: [actionCode:       1,
                                      actionName:       "unlock",
                                      eventName:        "unlock", 
                                      actionInProgress: "unlocking (waiting for Nuki bridge to finish operation)",
                                      actionSuccess:    "unlock command successfully sent (waiting for Nuki bridge confirmation)",
                                      actionFailure:    "unlocking failed"], 
                                  
                                  2: [actionCode:       2,
                                      actionName:       "lock",
                                      eventName:        "lock",
                                      actionInProgress: "locking (waiting for Nuki bridge to finish operation)",
                                      actionSuccess:    "lock command successfully sent (waiting for Nuki bridge confirmation)",
                                      actionFailure:    "locking failed"],
                                  
                                  3: [actionCode:       3,
                                      actionName:       "unlatch",
                                      eventName:        "unlatch",
                                      actionInProgress: "unlatching (waiting for Nuki bridge to finish operation)",
                                      actionSuccess:    "unlatch command successfully sent (waiting for Nuki bridge confirmation)",
                                      actionFailure:    "unlatching failed"],
                                  
                                  4: [actionCode:       4,
                                      actionName:       "lock 'n' go",
                                      eventName:        "lock",
                                      actionInProgress: "pausing 20 seconds before locking (lock 'n' go)",
                                      actionSuccess:    "'lock 'n' go' command successfully sent (waiting for Nuki bridge confirmation)",
                                      actionFailure:    "lock 'n' go failed"],
                                 
                                  5: [actionCode:       5,
                                      actionName:       "lock 'n' go with unlatch",
                                      eventName:        "lock",
                                      actionInProgress: "locking & unlatching (waiting for Nuki bridge to finish operation)",
                                      actionSuccess:    "locking & unlatching command successfully sent (waiting for Nuki bridge confirmation)",
                                      actionFailure:    "locking & unlatching failed"] \
                                  ]
@Field static List _lockStates = [[stateId: 0,
                                   stateName: "uncalibrated",
                                   progressText: "lock needs calibration"],
                                  
                                  [stateId: 1,
                                   stateName: "locked",
                                   progressText: "locking successful"],
                                 
                                  [stateId: 2,
                                   stateName: "unlocking",
                                   progressText: "unlocking in progress"],
                                 
                                  [stateId: 3,
                                   stateName: "unlocked", 
                                   progressText: "unlock successful"],
                                 
                                  [stateId: 4,
                                   stateName: "locking", 
                                   progressText: "locking in progress"],
                                 
                                  [stateId: 5,
                                   stateName: "unlatched",
                                   progressText: "unlatch successful"],
                                 
                                  [stateId: 6,
                                   stateName: "unlocked lockngo",
                                   progressText: "unlock 'n' go successful"],
                                 
                                  [stateId: 7,
                                   stateName: "unlatching",
                                   progressText: "unlatchin in progress"],
                                 
                                  [stateId: 253,
                                   stateName: "booting",
                                   progressText: "Nuki bridge booting - please wait"],
                                 
                                  [stateId: 254,
                                   stateName: "motor blocked",
                                   progressText: "motor blocked - please check your lock"],
                                 
                                  [stateId: 255,
                                   stateName: "undefined",
                                   progressText: "I don't know what to do ..."]
                                 ]
//@Field static Map lockActions2 = [0: "NO_ACTION", 1: "UNLOCK", 2: "LOCK", 3: "UNLATCH", 4: "LOCK_N_GO", 5: "LOCK_N_GO_WITH_UNLATCH"]
//@Field static Map lockDoorStatus = [0: "UNAVAILABLE", 1: "DEACTIVATED", 2: "DOOR_CLOSED", 3: "DOOR_OPENED", 4: "DOOR_STATE_UNKNOWN", 5: "CALIBRATING"]
//@Field static Map lockButtonActions = [0: "NO_ACTION", 1: "INTELLIGENT", 2: "UNLOCK", 3: "LOCK", 4: "UNLATCH", 5: "LOCK_N_GO", 6: "SHOW_STATUS"]

@Field static Map _deviceModes = [2: "Door mode"]

@Field static _nukiLockTypeName = "Nuki Smart Lock 2.0"    // Nuki Smart Lock 2.0's device driver name

@Field static String _deviceTypeSmartLock = "0"

metadata 
{
    definition (name: "Nuki Smart Lock 2.0", namespace: "maffpt", author: "Marco Felicio") 
    {
        capability "Battery"

        capability "Lock"
        command "lock"
        command "lockNGo"
        command "unlock"
        command "unlatch"
        
        command "getLog"
        command "status"
    }

    preferences 
    {
        input ("debugLogging",
               "bool",
               defaultValue: false,
               required: false,
               submitOnChange: true,
               title: "Enable debug logging\n<b>CAUTION:</b> a lot of log entries will be recorded!")
    }
    
    tiles 
    {
        standardTile ("getLog", "getLog", inactiveLabel: false, decoration: "flat", width: 3, height: 2) 
        {
        	state "default", action:"getLog", icon: "st.locks.lock.locked"
    	}

        standardTile ("lockNGo", "lockNGo", inactiveLabel: false, decoration: "flat", width: 3, height: 2) 
        {
            state "default", label:'lock&Go', action:"lockNGo", icon: "st.locks.lock.locked"
        }
    }
}


def initialize () 
{
  	logDebug "initialize: IN"
    logDebug "initialize: device.capabilities = ${device.capabilities}"
    logDebug "initialize: OUT"
}


def installed ()
{
    // if the parend device was running with debugLogging, it will automatically be passed to this device
    if (device.data.DebugLoggingRequired)
    {
        debugLogging = true
    }

  	logDebug "installed: IN"

    initialize()

    logDebug "installed: installed device ${device.data}"
    logDebug "installed: OUT"
}


def parse (Map jsonMap)
{
    logDebug "parse: IN"
    logDebug "parse: received jsonMap = ${jsonMap}"
    logDebug "parse: device.capabilities = ${device.capabilities}"
    
    // Let's first be sure that the NukiIds of this device and the parsed one are the same
    if (jsonMap.nukiId.toString () != device.data.data.DeviceId.toString ())
    {
        trow new Exception ("${device.data.label}: Inconsistent data - events from device with Nuki ID '${jsonMap.nukiId.toString ()}' cannot be handled by device hander for device '${device.data.data.DeviceId.toString ()}'")
    }
    
    logInfo "${device.data.label}: Status changed on this device to ${jsonMap.stateName.toUpperCase ()}. Battery status is ${jsonMap.batteryCritical ? "CRITICAL" : "NORMAL"}."

    sendLockEvent (jsonMap.stateName)
    sendBatteryEvent (jsonMap.batteryCritical)

    def lockState = _lockStates.find { it.stateName.toUpperCase () == jsonMap.stateName.toUpperCase ()}
    logDebug "parse: lockState = ${lockState}"
    
    sendProgressEvent (lockState?.progressText)

    logDebug "parse: OUT"
}


def parse (String description)
{
    logDebug "parse: IN"
    
    def parsedDescription = parseLanMessage (description)
    logDebug "parse: parsed description = ${parsedDescription}"
    
    logDebug "parse: OUT"
}


def uninstalled ()
{
    logDebug "uninstalled: IN"

    logInfo "${device.label}: Nuki device '${device.label}' successfully uninstalled"
       
    logDebug "uninstalled: OUT"
}


def updated () 
{
    logDebug "updated: IN"

    logDebug "updated: OUT"
}


// ======================================
// Device specific methods
// ======================================


def getLog ()
{
    logDebug "getLog: IN"
    
    def nukiLog = sendRequestToNuki (request: "log").data
    logDebug "getLog: processing response"    
    
    nukiLog.each
    {
        logInfo (it.value)
    }
    
    logInfo "${_nukiLockTypeName}: Nuki bridge log information copied to this Hubitat Elevation hub log"
    
    logDebug "getLog: OUT"
}


//
// Lock
//
def lock (Map cmds) 
{
    logDebug "lock: IN"
    logDebug "lock: cmds = ${cmds}"
    //logDebug "lock: device.capabilities = ${device.capabilities}"

    sendCommandToNuki (_lockActions [2],       // action = "lock"
                       true)                   // waitCompletition

    logDebug "lock: OUT"
}


def lockNGo ()
{
    logDebug "lockNGo: IN"

    sendCommandToNuki (_lockActions [4],       // action = "lock 'n' go"
                       false)                  // waitCompletition

    logDebug "lockNGo: OUT"
}


//
// Recover device's current status
//
def status ()
{
    logDebug "status: IN"
    logDebug "status: device.data = ${parent.device.data}"
    
    def deviceInfo = getDeviceInfo (device.data.data, parent.data)
    logDebug "status: deviceInfo = ${deviceInfo}"
    
    def deviceMode = _deviceModes.find { it.key == deviceInfo?.mode }
    logDebug "status: deviceMode = ${deviceMode.value}"

    def deviceStatus = "Device mode: ${deviceMode.value} //\n" +
                       "State: ${deviceInfo?.stateName} //\n" +
                       "Battery: ${deviceInfo?.batteryCritical ? "CRITICAL" : "NORMAL"} //\n\n"+
                       "<b>NOTE</b>: avoid requesting this status frequently since it may drain your lock's batteries too fast."
    
    sendLockEvent (deviceInfo?.stateName)
    sendProgressEvent (deviceStatus, deviceInfo)
    
    logDebug "status: OUT"
}


def unlatch ()
{
    logDebug "unlatch: IN"
    
    sendCommandToNuki (_lockActions [3],       // action = "unlatch"
                       true)                   // waitCompletition
    
    logDebug "unlatch: OUT"
}

def unlock (Map cmds) 
{
    logDebug "unlock: IN"
    logDebug "unlock: cmds = ${cmds}"
    
    sendCommandToNuki (_lockActions [1],       // action = "unlock"
                       true)                   // waitCompletition


    logDebug "unlock: OUT"
}


//=========================================
//    Support stuff
//=========================================


//
// Retrieve information about a bridge
//
def getDeviceInfo (deviceData, parentData)
{
    logDebug "getDeviceInfo: IN"
    logDebug "getDeviceInfo: deviceData = ${deviceData}"
    logDebug "getDeviceInfo: parentData = ${parentData}"

    def httpRequest = "${parent.buildBridgeURL (parentData)}/lockState?nukiId=${deviceData.DeviceId}&deviceType=${deviceData.DeviceType}&token=${parentData.Token}"
    logDebug "getBridgeInfo: httpRequest = ${httpRequest}"

    def deviceInfo

    try
    {
	    httpGet (httpRequest)
		{
            resp ->           
                logDebug "refresh: resp data: ${resp.data}"
                deviceInfo = resp.data
        }
    }
    catch (e)
    {
        throw new Exception ("${parent.device.data.Label}: method 'getBridgeInfo' - Fatal error = ${error}")
    }     

    logDebug "getBridgeInfo: OUT"
    
    return deviceInfo
}


//
// Format and send a command to the Nuki device, handling the result
//
def sendCommandToNuki (Map action, boolean waitCompletition) 
{
    logDebug "sendCommandToNuki: IN"
    logDebug "sendCommandToNuki: Processing action specs = ${action}"

    def returnData
        
    def deviceStatus
    def actionNameUCase = action.actionName.toUpperCase ()
    def actionNameLCase = action.actionName.toLowerCase ()
    def endLoop = false
    def sendCommand = false
    def errorMessage = ""
    
    sendProgressEvent (action.actionInProgress)

    for (i in 1..3) 
    {
        deviceStatus = parent.getNukiDeviceStatus (device.data.data)
        logDebug "sendCommandToNuki: deviceStatus = ${deviceStatus}"
        
        logDebug "sendCommandToNuki: stateName = ${deviceStatus.lastKnownState.stateName.toUpperCase ()}"
        
        switch (deviceStatus.lastKnownState.stateName.toUpperCase ())
        {
            case "UNCALIBRATED":
                logDebug "sendCommandToNuki: falling through case 'UNCALIBRATED'"
                errorMessage = "Nuki device not calibrated - use Nuki smartphone app to calibrate it"
                sendCommand = false
                endLoop = true
                break
            case "LOCKED":
                logDebug "sendCommandToNuki: falling through case 'LOCKED'"
                switch (actionNameUCase)
                {
                    case "LOCK":
                    case "LOCK 'N' GO":
                    case "LOCK 'N' GO WITH UNLATCH":
                        logDebug "sendCommandToNuki: falling through case 'LOCKED', subcase 'LOCK'/'LOCK 'N' GO'/'LOCK 'N' GO WITH UNLATCH'"
                        errorMessage = "Nuki device already locked - ${actionNameUCase} command ignored"
                        sendCommand = false
                        endLoop = true
                        break
                    case "UNLATCH":
                    case "UNLOCK":
                        logDebug "sendCommandToNuki: falling through case 'LOCKED', subcase 'UNLATCH'/'UNLOCK'"
                        sendCommand = true
                        endLoop = true
                        break
                    default:
                        logDebug "sendCommandToNuki: falling through case 'LOCKED', subcase 'default'"
                        break
                }
                break
            case "LOCKING":
            case "UNLATCHING":
            case "UNLOCKING":
                logDebug "sendCommandToNuki: falling through case 'LOCKING'/'UNLATCHING'/'UNLOCKING'"
                // Let's give some time to the lock to complete the current operation
                break
            case "UNLATCHED":
                logDebug "sendCommandToNuki: falling through case 'UNLATCHED'"
                switch (actionNameUCase)
                {
                    case "LOCK":
                    case "LOCK 'N' GO":
                    case "LOCK 'N' GO WITH UNLATCH":
                        logDebug "sendCommandToNuki: falling through case 'UNLATCHED', subcase 'LOCK'/'LOCK 'N' GO'/'LOCK 'N' GO WITH UNLATCH'"
                        sendCommand = true
                        endLoop = true
                        break
                    case "UNLATCH":
                        logDebug "sendCommandToNuki: falling through case 'UNLATCHED', subcase 'UNLATCH'"
                        errorMessage = "Nuki device already unlatched - ${actionNameUCase} command ignored"
                        sendCommand = false
                        endLoop = true
                        break
                    case "UNLOCK":
                        logDebug "sendCommandToNuki: falling through case 'UNLATCHED', subcase 'UNLOCK'"
                        errorMessage = "Nuki device already unlocked & unlatched - ${actionNameUCase} command ignored"
                        sendCommand = false
                        endLoop = true
                        break
                    default:
                        logDebug "sendCommandToNuki: falling through case 'UNLATCHED', subcase 'default'"
                        break
                }
                break
            case "UNLOCKED":
            case "UNLOCKED (LOCK 'N' GO)":
                logDebug "sendCommandToNuki: falling through case 'UNLATCHED'/'UNLOCKED'/'UNLOCKED (LOCK 'N' GO)'"
                switch (actionNameUCase)
                {
                    case "LOCK":
                    case "LOCK 'N' GO":
                    case "LOCK 'N' GO WITH UNLATCH":
                        logDebug "sendCommandToNuki: falling through case 'UNLOCKED'/'UNLOCKED (LOCK 'N' GO)', subcase 'LOCK'/'LOCK 'N' GO'/'LOCK 'N' GO WITH UNLATCH'"
                        sendCommand = true
                        endLoop = true
                        break
                    case "UNLATCH":
                        logDebug "sendCommandToNuki: falling through case 'UNLOCKED'/'UNLOCKED (LOCK 'N' GO)', subcase 'UNLATCH'"
                        sendCommand = true
                        endLoop = true
                        break
                    case "UNLOCK":
                        logDebug "sendCommandToNuki: falling through case 'UNLOCKED'/'UNLOCKED (LOCK 'N' GO)', subcase 'UNLOCK'"
                        errorMessage = "Nuki device already unlocked - ${actionNameUCase} command ignored"
                        sendCommand = false
                        endLoop = true
                        break
                    default:
                        logDebug "sendCommandToNuki: falling through case 'UNLOCKED'/'UNLOCKED (LOCK 'N' GO)', subcase 'default'"
                        break
                }
                break
            case "MOTOR BLOCKED":
                logDebug "sendCommandToNuki: falling through case 'MOTOR BLOCKED'"
                errorMessage = "Nuki lock motor blocked - calibrate the lock using the Nuki smartphone app; please check system log for more information on how to proceed"
                logWarn "${device.data.label}: 9. When the calibration is finhised, re-execute the previously failed operation"
                logWarn "${device.data.label}: 8. Follow the instructions provided by the Nuki app"
                logWarn "${device.data.label}: 7. Select the 'Calibrate Smart Lock' option"
                logWarn "${device.data.label}: 6. Select the 'Manage Smart Lock' option"
                logWarn "${device.data.label}: 5. Choose this smart lock (${device.data.label})"
                logWarn "${device.data.label}: 4. Select the 'Smart Lock' option"
                logWarn "${device.data.label}: 3. Select the 'Manage my devices' menu item"
                logWarn "${device.data.label}: 2. Open the Nuki menu (touch the tree bars icon on the top left part of the screen)"
                logWarn "${device.data.label}: 1. Access the Nuki app on your smartphone"
                logWarn "${device.data.label}: To unblock it, follow these instructions:"
                logWarn "${device.data.label}: The motor in this Nuki smart lock is blocked"
                sendCommand = false
                endLoop = true
                break
            case "UNDEFINED":
                logDebug "sendCommandToNuki: falling through case 'UNDEFINED'"
                errorMessage = "Nuki device has an UNDEFINED status - please try again latter"
                sendCommand = false
                endLoop = true
                break
        }
        if (endLoop)
        {
            break
        }
        logInfo "sendCommandToNuki: pausing for 1.5 seconds"
        pauseExecution (1500)
    }

    if (sendCommand)
    {
        try
        {
            def httpRequest = "${parent.buildBridgeURL (parent.data)}/lockAction?${buildNukiLockActionCommand (action.actionCode, waitCompletition)}"
            logDebug "sendCommandToNuki: httpRequest = ${httpRequest})"
    	    httpGet (httpRequest)
            {
                resp -> 
                    returnData = resp?.data
            }
            if (returnData?.success)
            {
                //logDebug "sendCommandToNuki: event name = lock - value = ${eventSuccessValue}"
                //sendLockEvent (eventSuccessValue)
            }
            else
            {
                logWarn "${_nukiLockTypeName}: sending of command '${action.actionName}' to Nuki lock unsuccessful"
            }
        }
        catch (err)
        {
            logDebug ("sendCommandToNuki: Error on httpPost = ${err}")
        }
    }
    
    if (errorMessage == "")
    {
        sendProgressEvent (action.actionSuccess)
    }
    else
    {
        sendProgressEvent ("${action.actionFailure} - see device events for more information by clicking on the 'Events' button at the top of this page", errorMessage)
        logWarn "${_nukiLockTypeName}: ${errorMessage}"
        returnData = false
    }
    logDebug "sendCommandToNuki: OUT"
    
    return returnData
}


def buildNukiLockActionCommand (actionCode, waitCompletition)
{
    logDebug "buildNukiLockActionCommand: IN"
    logDebug "buildNukiLockActionCommand: actionCode = ${actionCode}, waitCompletition = ${waitCompletition}"
    
    def httpBody
    
    if (actionCode != null)
    {
        logDebug "buildNukiLockActionCommand: device.data.data = ${device.data.data}"
        httpBody = "nukiId=${device.data.data.DeviceId}" +
                   "&deviceType=${_deviceTypeSmartLock}" +
                   "&action=${actionCode}" +
                   "&token=${parent.data.Token}" +
                   "&nowait=${waitCompletition ? 0 : 1}"
    }
    else
    {
        log.debug "buildNukiLockActionCommand: OUT with exception"
        throw new Exception ("Invalid action description (${actionDescription})")
    }
    logDebug "buildNukiLockActionCommand: httpBody = ${httpBody}"
    logDebug "buildNukiLockActionCommand: OUT"

    return httpBody
}


def sendRequestToNuki (String request)
{
    logDebug "sendRequestToNuki: IN"
    logDebug "Processing ${request} request"
    
    def returnData
    
    try
    {
        def requestToSend = buildNukiLockRequest (request)
    	httpPost ( requestToSend )
        {
            resp ->
                returnData = resp.data
        }
    }
    catch (err)
    {
        handleHttpError (err)
    }

    logDebug "sendRequestToNuki: OUT"
    
    return returnData
}


def buildNukiLockRequest (request)
{
    logDebug "buildNukiLockRequest: IN"
    def requestToSend = "http://${state.ip}/${request}?token=${state.token}"
    
    logDebug "buildNukiLockRequest: requestToSend = ${requestToSend}"
    logDebug "buildNukiLockRequest: OUT"
    
    return requestToSend
}


def handleHttpError (errorCode)
{
    logDebug "handleHttpError: IN"
    logDebug "handleHttpError: errorCode = ${errorCode}"
    switch (errorCode)
    {
        case 401:
            sendEvent (name: "errorCode", value: "Invalid token")
            break
        case 403:
            sendEvent (name: "errorCode", value: "Authentication disabled")
            break
        case 404:
            sendEvent (name: "errorCode", value: "Nuki device unknown")
            break
        case 503:
            sendEvent (name: "errorCode", value: "Nuki device is offline")
            break
        default:
            sendEvent (name: "errorCode", value: "Unexpected error (${errorCode})")
            break
    }
    
    logDebug "handleHttpError: OUT"
}


def sendBatteryEvent (batteryCritical)  
{
    logDebug "sendBatteryEvent: IN"

    sendEvent (name: "battery", value: (batteryCritital ? 20 : 100), unit: "%")          

    logDebug "sendBatteryEvent: OUT"
}


def sendErrorEvent (errorMessage, errorDescription = "")
{
    logDebug "sendErrorEvent: IN"

    sendEvent (name: "error", value: errorMessage, descriptionText: errorDescription)          

    logDebug "sendErrorEvent: OUT"
}


def sendLockEvent (lockStatus)
{
    logDebug "sendLockEvent: IN"
    logDebug "sendLockEvent: lockStatus = ${lockStatus}"

    sendEvent (name: "lock", value: lockStatus) 

    logDebug "sendLockEvent: OUT"
}


def sendProgressEvent (status, statusMessage = "")
{
    logDebug "sendProgressEvent: IN"
    logDebug "sendProgressEvent: status = ${status} / statusMessage = ${statusMessage}"

    sendEvent (name: "progress", value: status, descriptionText: statusMessage)          

    logDebug "sendProgressEvent: OUT"
}


// Logging stuff
def logDebug (message) { if (debugLogging) log.debug (message) }
def logInfo  (message) { log.info (message) }
def logWarn  (message) { log.warn (message) }
